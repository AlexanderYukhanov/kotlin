package

@kotlin.native.RefinedForObjC @kotlin.native.RefinedInSwift public var refinedProperty: kotlin.Int
@kotlin.native.RefinedForObjC @plugin.PluginRefinedForObjC @kotlin.native.RefinedInSwift @plugin.PluginRefinedInSwift public fun multipleMixedRefinementsFunction(): kotlin.Unit
@kotlin.native.RefinedForObjC @plugin.PluginRefinedForObjC public fun multipleObjCRefinementsFunction(): kotlin.Unit
@kotlin.native.RefinedInSwift @plugin.PluginRefinedInSwift public fun multipleSwiftRefinementsFunction(): kotlin.Unit
@plugin.PluginRefinedForObjC @plugin.PluginRefinedInSwift public fun pluginRefinedFunction(): kotlin.Unit

public open class ClassA : InterfaceA, InterfaceB {
    public constructor ClassA()
    @kotlin.native.RefinedForObjC public open override /*2*/ val barA: kotlin.Int = 0
    @kotlin.native.RefinedInSwift public open override /*2*/ val barB: kotlin.Int = 0
    public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
    public open override /*2*/ fun fooA(): kotlin.Unit
    public open override /*2*/ fun fooB(): kotlin.Unit
    @kotlin.native.RefinedForObjC public open fun fooC(): kotlin.Unit
    public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
    public open override /*2*/ /*fake_override*/ fun toString(): kotlin.String
}

public final class ClassB : ClassA {
    public constructor ClassB()
    @kotlin.native.RefinedForObjC public open override /*1*/ /*fake_override*/ val barA: kotlin.Int
    @kotlin.native.RefinedInSwift public open override /*1*/ /*fake_override*/ val barB: kotlin.Int
    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
    public open override /*1*/ /*fake_override*/ fun fooA(): kotlin.Unit
    @kotlin.native.RefinedForObjC public open override /*1*/ fun fooB(): kotlin.Unit
    @kotlin.native.RefinedInSwift public open override /*1*/ fun fooC(): kotlin.Unit
    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
}

public interface InterfaceA {
    public abstract val barA: kotlin.Int
    public abstract val barB: kotlin.Int
    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
    public abstract fun fooA(): kotlin.Unit
    @kotlin.native.RefinedForObjC public abstract fun fooB(): kotlin.Unit
    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
}

public interface InterfaceB {
    public abstract val barA: kotlin.Int
    @kotlin.native.RefinedInSwift public abstract val barB: kotlin.Int
    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
    @kotlin.native.RefinedForObjC public abstract fun fooA(): kotlin.Unit
    @kotlin.native.RefinedForObjC public abstract fun fooB(): kotlin.Unit
    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
}

@kotlin.native.RefinesForObjC @kotlin.native.RefinesInSwift @kotlin.annotation.Target(allowedTargets = {AnnotationTarget.PROPERTY, AnnotationTarget.FUNCTION}) @kotlin.annotation.Retention(value = AnnotationRetention.BINARY) public final annotation class MyRefinedAnnotation : kotlin.Annotation {
    public constructor MyRefinedAnnotation()
    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
}

package kotlin {

    package kotlin.native {

        @kotlin.native.RefinesForObjC @kotlin.annotation.Target(allowedTargets = {AnnotationTarget.PROPERTY, AnnotationTarget.FUNCTION}) @kotlin.annotation.Retention(value = AnnotationRetention.BINARY) public final annotation class RefinedForObjC : kotlin.Annotation {
            public constructor RefinedForObjC()
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        @kotlin.native.RefinesInSwift @kotlin.annotation.Target(allowedTargets = {AnnotationTarget.PROPERTY, AnnotationTarget.FUNCTION}) @kotlin.annotation.Retention(value = AnnotationRetention.BINARY) public final annotation class RefinedInSwift : kotlin.Annotation {
            public constructor RefinedInSwift()
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        @kotlin.annotation.Target(allowedTargets = {AnnotationTarget.ANNOTATION_CLASS}) @kotlin.annotation.Retention(value = AnnotationRetention.BINARY) @kotlin.annotation.MustBeDocumented public final annotation class RefinesForObjC : kotlin.Annotation {
            public constructor RefinesForObjC()
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        @kotlin.annotation.Target(allowedTargets = {AnnotationTarget.ANNOTATION_CLASS}) @kotlin.annotation.Retention(value = AnnotationRetention.BINARY) public final annotation class RefinesInSwift : kotlin.Annotation {
            public constructor RefinesInSwift()
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }
    }
}

package plugin {

    @kotlin.native.RefinesForObjC @kotlin.annotation.Target(allowedTargets = {AnnotationTarget.PROPERTY, AnnotationTarget.FUNCTION}) @kotlin.annotation.Retention(value = AnnotationRetention.BINARY) public final annotation class PluginRefinedForObjC : kotlin.Annotation {
        public constructor PluginRefinedForObjC()
        public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
        public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
        public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
    }

    @kotlin.native.RefinesInSwift @kotlin.annotation.Target(allowedTargets = {AnnotationTarget.PROPERTY, AnnotationTarget.FUNCTION}) @kotlin.annotation.Retention(value = AnnotationRetention.BINARY) public final annotation class PluginRefinedInSwift : kotlin.Annotation {
        public constructor PluginRefinedInSwift()
        public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
        public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
        public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
    }
}
